<resources>
    <string name="app_name">Learn Android</string>
    <string name="getStarted">Get Started</string>
    <string name="next">Next</string>
    <string name="contactUs">Contact Us</string>
    <string name="aboutUs">About Us</string>
    <string name="aboutDetails">I\'m Onotu Umoru. The developer of this very informative app. I am an expert at android development and belong to the top top one percent of programmers around the world. The purpose is to inform readers of the basics of android.</string>
    <string name="contactDetails">On the absolutely rare chance you found a bug ( : \n Contact me at-> \n email: onotu128@gmail.com \n phone: +2347037816672</string>
    <string name="roadmap">Android Developer Roadmap 2022 \n Knowing what to learn in Android Development\nThe intent of this guide is to give you an idea about the Android development landscape and to help guide your learning if you are confused. Before we start, please note that the roadmap is opinionated, and you might have different opinions than those of the author. Having said that, we would love to hear your opinions and incorporate them into the roadmap if suitable.\nThere are multiple ways to develop applications for the android; you can go down the path of hybrid application development where flutter, react-native, or Native Script are the most common contenders. Flutter uses Dart, whereas React Native and Native Script rely on JavaScript. Answering the question of hybrid vs native is out of the scope of this roadmap. This roadmap is focused on the native Android apps development but if you are interested in learning any hybrid framework, my personal preference is react-native, and I would recommend you to check out the Frontend Developer Roadmap.\n
Broken Down Version\n Below is the broken-down version of the roadmap, with links and resources to learn more about each of the items listed in the complete roadmap above.\nPick a Language\n
For the languages, you can develop android apps either by using Kotlin or Java.\n\nIf you are a beginner, I will recommend you to go with Kotlin as it is also preferred by the Google team and many Android developers.\n\n\nAlthough you can use both Kotlin and Java to develop native android apps, Google announced in 2019 to make Kotlin the preferred way of developing android applications. If you were to start learning android development today, Kotlin should be your language of choice.\nThe Fundamentals\n
Install the Android Studio and learn the basics of Kotlin to get startd.\n\n\nWe have also listed down some free resources which you can use for the items listed in the image above. If you have some better ones, please do suggest. Also, you don’t need to go through all of them, just go through them and pick what you like.\n\n
Learn the basics of Kotlin\n
Kotlin Docs and Official Kotlin Tutorials\n
Data Structures and Algorithms. Also, check this.\n
Kotlin Data Structures\n
Algorithms and Data Structures in Kotlin\n
Version Control Systems\n
Version control systems record your changes to the codebase and allow you to recall specific versions later. There are multiple Version Control Systems available but Git is the most common one these days.\n
\n
\n
Here are some of the resources to get you started. Feel free to google and find something else that you find easier.

Udacity — Version Control with Git
GitHub Hello World
Building an Application
Here is the list of items that you are going to need when developing Android applications. Please note that this is an exhaustive list, and you don’t need to know it all from the get-go. Get an idea of the items listed, and just start building some apps keep the items listed in the back of your mind and have a deep dive when using them.
\n
\nv
To learn more about the items listed in the image above, here are the links to the relevant docs\n
\n
Using Activities and Activity Life Cycles
Building Flexible Interfaces using Fragments
Debugging using Android Studio Debugger
Handling App Configurations
Using Intents and Intent Filters
Understand Context
Learn about Multithreading
Data Privacy
Securing Network Data
Dependency Injection
Content Providers
Glide, Retrofit, Crashlytics, GSON
Room, Navigation, Work Manager, LiveData, Data Binding
RxJava, RxKotlin
Memory Management Overview
Diving deeper into context-oriented programming in Kotlin
I would highly recommend watching this free course from Google on Developing Android Apps with Kotlin. Also, here are some of the resources to learn more about the topics listed above.\n
\n
Developing Android Apps with Kotlin
Android Developer Guides
Raywenderlich\n
Wrap Up\n
Thanks for reading, remember always to keep motivated and don’t get exhausted by doing everything at once. Do little by little and accomplish things and achieve your DREAM……\n</string>
    <string name="kotlinorjava">Kotlin vs Java \n
Checked Exceptions. One major difference between Java and Kotlin is that the latter has no provision for checked exceptions.
Code Conciseness. Comparing a Java class with an equivalent Kotlin class demonstrates the conciseness of Kotlin code. …
Coroutines. CPU-intensive work and network I/O are long-running operations. The calling thread is blocked until the whole operation completes.
Data Classes. Full-size projects have several classes that are solely meant to hold data. …
Extension Functions. Kotlin allows developers to extend a class with new functionality via extension functions. These functions, although available in other programming languages like C#, arent available in Java.
Higher-Order Functions and Lambdas. A higher-order function is one that takes functions as parameters or returns a function. Also, Kotlin functions are first-class.
Implicit Widening Conversions. There is no support for implicit widening conversions for numbers in Kotlin. So, smaller types arent able to get converted to bigger types.
Inline Functions. Variables that are accessed in the body of the function are known as closures. Making use of higher-order functions can impose several runtime penalties.
Native Support for Delegation. In programming terminology, Delegation represents the process where a receiving object delegates operations to a second delegate object.
Non-private Fields. Encapsulation is essential in any program for achieving a desirable level of maintainability. …
Null Safety. One of the most infuriating issues concerning Java for developers is the NullPointerExceptions. Java lets developers assign a null value to any variable.
Primitive Types. There are 8 primitive data types, including char, double, float, and int. Unlike Kotlin, variables of a primitive type arent objects in Java.
Smart Casts. Before an object can be cast in Java, it is mandatory to check type. This is also true in scenarios where its obvious to cast the object.
Static Members. Kotlin has no provision for static members. However, in Java programming language the keyword static reflects that the particular member with which the keyword is used belongs to …
Support for Constructors. A Kotlin class, unlike a Java class, can have one or more secondary constructors in addition to a primary constructor.
Ternary Operator. Unlike Kotlin, Java has a ternary operator. The Java ternary operator simply works like a basic if statement.
Wildcard Types. In generic code, ? represents an unknown type. It is known as the wildcard</string>

<string name="vControl">Version control systems are a category of software tools that help a software team manage changes to source code over time.</string>
 <string name="github">GitHub is a Git repository hosting service, but it adds many of its own features. While Git is a command line tool, GitHub provides a Web-based graphical interface. It also provides access control and several collaboration features, such as a wikis and basic task management tools for every project. The flagship functionality of GitHub is “forking” – copying a repository from one user’s account to another. This enables you to take a project that you don’t have write access to and modify it under your own account. If you make changes you’d like to share, you can send a notification called a “pull request” to the original owner. That user can then, with a click of a button, merge the changes found in your repo with the original repo. These three features – fork, pull request and merge – are what make GitHub so powerful. Gregg Pollack of Code School (which just launched a class called TryGit) explains that before GitHub, if you wanted to contribute to an open source project you had to manually download the project’s source code, make your changes locally, create a list of changes called a “patch” and then e-mail the patch to the project’s maintainer. The maintainer would then have to evaluate this patch, possibly sent by a total stranger, and decide whether to merge the changes. This is where the network effect starts to play a role in GitHub, Pollack explains. When you submit a pull request, the project’s maintainer can see your profile, which includes all of your contributions on GitHub. If your patch is accepted, you get credit on the original site, and it shows up in your profile. It’s like a resume that helps the maintainer determine your reputation. The more people and projects on GitHub, the better idea picture a project maintainer can get of potential contributors. Patches can also be publicly discussed. Even for maintainers who don’t end up using the GitHub interface, GitHub can make contribution management easier. “I end up just downloading the patch anyway, or merging from the command line instead of from the merge button,” says Isaac Schlueter, the maintainer of the open source development platform Node.js. “But GitHub provides a centralized place where people can discuss the patch.” Lowering the barrier to entry democratizes open source development, and helps young projects grow. “Node.js wouldn’t be what it is today without GitHub,” Schlueter says. Besides its public facing open source repositories, GitHub also sells private repositories and on-premise instances of its software for enterprises. These solutions obviously can’t take full advantage of GitHub’s network effect, but they can take advantage of the collaboration features. That’s how GitHub makes money, but it’s not alone in this market. Atlassian acquired a competitor called BitBucket in 2010. And earlier this year Atlassian launched Stash, a product that enables you to host private, on-premise Git repositories with BitBucket/GitHub-style collaboration features. The company also sells developer collaboration tools like the bug tracker Jira and the wiki Confluence. Competition from Atlassian, which took $60 million in funding from Accel Partners in 2010, could help explain why GitHub took this round of funding, and hint at some possible future directions for the company. For example, Schlueter says GitHub’s issue tracking feature could eventually compete with JIRA for some projects.The money may be in private and on-premise hosting, but the love is in the public repositories. Perhaps most importantly, GitHub has become the Library of Alexandria for code examples. Since Git encourages granular recording of changes, programmers, be they absolute beginners or experts, can trace the steps of some of the greatest developers in the world and find out how they solved thorny problems. But if GitHub were ever to meet the same fate as the Library of Alexandria, it could be reconstructed from all those local forks distributed on so many developers laptops all over the world. Regardless of how this investment works out, that’s a hell of a legacy for the GitHub team to leave behind.</string>
    <string name="ide">" Modern IDE for programming    Software development is a fast-moving, fast-evolving discipline that is at the heart of digital products of many businesses. Keeping up with the pace of emerging technologies, increasing demand for faster application development, while at the same time extracting value from existing solutions are all major drivers of the rise in Integrated Development Environment (IDE) adoption.  Making the best of programming IDEs What is an IDE? IDEs are software tools and applications that simplify software development and software design by grouping together everything a software developer might need to program software. In the IDE in programming unified interface, software developers can find a code editor to write and edit source code, a debugger to debug to their heart’s content, a compiler to transform source code written in human readable/writable language to something computers can understand, and automation tools to automate routine development tasks.   That’s not all, of course. Modern programmer IDEs are now packed with class browsers to study and reference properties, object browsers to inspect objects, and class hierarchy diagrams to visualize object-oriented programming code, to name a few.  In short, IDEs are designed to maximize software developer productivity by encompassing tight-knit components, making it the ideal playground where they can write, test, and do everything they like with their code.   Role of an Integrated Development Environment in software programming Before IDE programming, there were text editors. Developers would write and save applications in the text editor of their choice before running a compiler, noting error messages, and fixing their code accordingly.  The IT industry is always in search of making the lives of software developers easier, and in 1991, Microsoft’s Visual Basic was launched as the first real IDE. Since then, IDEs have come a long way in improving the productivity of developers. From shortening setup time, speeding up development tasks, keeping developers updated with the latest best practices, and standardizing the development process, IDEs value to the work of software development is evident.  Its holistic approach to strategic software development application is what drives software developers to think of their contributions as a whole in terms of the Software Development Lifecycle (SDLC), instead of going about things as if they were isolated tasks.  Programming Languages Support in IDE  Some IDEs are designed with one programming language in mind, making it easier to offer features and capabilities that are perfectly in sync with that specific language and closely match its programming paradigms. Some noteworthy mentions include Cocoa and Cocoa Touch APIs and Xcode for the Swift language. Keep in mind that if you choose an IDE that only supports a specific language, there are almost always plugins that help IDEs support alternative languages.  In stark contrast, there are several IDEs that are language agnostic or that support many different software for programming languages like Eclipse that supports PHP, Java, Ruby, Python, C, C++, and many more.  Best Integrated Development Environment Software developers favor the use of IDEs because it allows them to develop software quickly by having all utilities in one place without having to manually configure or integrate to any external application for software development.   Most IDEs are designed to save time thanks to capabilities like intelligent code completion or automated code generation. Also, the organization and problem-solving workflows embedded in IDEs help developers identify, and sometimes solve, problems in real time.  As with all good things, there’s always variety to choose from and IDEs are no exception. There are different business and technical use cases that set IDEs apart, including:  Supported languages. As stated above, some IDEs are designed with one programming language in mind while others are a good fit for several languages, all in one. Operating systems. IDEs are viable for specific operating systems unless the IDE is cloud-based. For example, if the operating system is Android, there are specific IDEs for the Android operating system.  System performance. Memory footprint is critical when developers want to run memory-intensive applications in tandem. Plugins. Some IDEs are capable of customizing workflows to align with the requirements of a specific software development app project. Automation features. Some IDEs now include key automation features such as continuous integration and continuous deployment tools, refactoring, and code search. HTML. HTML-focused IDEs are some of the most popular ones, including developer favorites such as HomeSite, DreamWeaver, and FrontPage, that automate website development tasks with web applications development tools and the web development IDE. Mobile. There’s no denying it, mobile apps became a staple in the last couple of years, and many software products are now designed with smartphones and tablets in mind. IDEs provide cross-platform support for iOS and Android for multiple operating systems. Cloud. Cloud-based IDEs are flexible, lightweight, and require no software installation. Cloud IDEs are centrally managed, helping avoid intellectual property and security concerns. Additionally, cloud IDEs have superior computing power, allowing developers to run compute-intensive jobs without compromising performance or monopolizing compute resources. Last but not least, cloud IDEs are platform agnostic. As of January of last year, the most commonly searched IDEs are Visual Studio, Android  Studio, and Eclipse.  Visual Studio (and Visual Code) Microsoft’s IDE in Visual Studio is packed with development tools for Python that helps software developers create console and graphical user interface applications with Windows Forms, web sites, web applications, and web services. Visual Studio supports VB.NET, C#, F#, and more.  For many, Visual Studio is the best IDE for Python for Windows development. Developers typically seek out the capabilities of Visual Studio for its seamless integrations with Django and Flask frameworks. Whether developers are using Visual Studio as the Python IDE in Mac, the Windows IDE for Python, the Linux IDE for Python, or the Python IDE on Ubuntu, Visual Studio is considered the best Python free IDE.   IntelliJ IDEA Considered as one of the most popular IDEs for Java and Android developres, IntelliJ IDEA includes a wide array of powerful features coupled with smart code intelligence algorithms that reduce code-writing, streamlines syntax detection, and builds errors efficiently.  IntelliJ IDEA is well-suited for web, enterprise, and mobile Java development, while providing world-class support and productivity capabilities for Scala and Groovy.  XCode: development tools for iOS Apple’s proprietary IDE is used exclusively to design and develop Apple products as it’s packed with development tools iOS. From start to finish, developers can manage the entire software development workflow in the confidence that the environment supports languages like Swift, Objective-C, and C++.  Built with Swift, Cocoa, and Cocoa Touch in mind, Xcode tools make programming a seamless, dynamic experience with live rendering via the Interface Builder that displays hand-written UI code inside the canvas to instantly reflect changes you type in code.  Android Studio: development tools Android The official Android IDE, this environment builds high-quality Android apps for, you guessed it, Android devices thanks to its development tools for Android apps. Android Studio supports Java and Kotlin. Originally designed based on IntelliJ IDEA, Android is an IDE for mobile app development specific to the Android platform.  The Android Studio provides features that make it easy to interact with mobile capabilities such as push notifications, camera integrations, and more. This IDE is a flexible, and gradle-based system that enables developers to build variants and multiple APKs, as well as gain expanded template support for Google Services."</string>
    <string name="activities">An Android activity is one screen of the Android app\'s user interface. In that way an Android activity is very similar to windows in a desktop application. An Android app may contain one or more activities, meaning one or more screens. The Android app starts by showing the main activity, and from there the app may make it possible to open additional activities.  Activity Life Cycle Any Android activity goes through a certain life cycle during its life inside the Android app. This life cycle is illustrated here:  Android activity life cycle. When an Android app is first started the main activity is created. The activity then goes through 3 states before it is ready to serve the user: Created, started and resumed.  If the main activity can open any other activities (screens) these activities will go through the same 3 states when they are opened.  If an activity A opens another activity B, then activity A will be paused. This means that activity A goes into the paused state. When the user clicks the back button and returns to activity A, activity A returns to the resumed state.  If the user returns to the home screen of the Android device, all activities will be paused and then stopped. If the user then returns to the app, the activities will go through the started and then resumed states. If the Android device needs the memory that the Android app occupies in the device\'s memory, then it may completely destroy the app, meaning the Android activities go into the destroyed state.  Note that the states always follows the arrows in the diagram. An activity cannot jump from created to resumed directly. An activity will always go through created, started and resumed in that sequence. An activity may change from resumed to paused an back, and from paused to stopped and back to started, but never from stopped directly to resumed.  Activity Life Cycle Methods All activities in your Android apps are represented by an activity class. These activity classes are subclasses of android.app.Activity. The Activity class contains a set of methods that corresponds to the life cycle states an activity can be in. These methods are:  onCreate() onStart() onRestart() onResume() onPause() onStop() onDestroy() When activity is to transition into one of the life cycle states, the corresponding life cycle method is called on the Activity subclass instance. When the life cycle method finishes the activity is assumed to be in the new life cycle state. For instance, once the onCreate() life cycle method returns, the activity is assumed to be in the created state.  As mentioned earlier, all Android activities are subclasses of the Activity class. The Activity class contains the above listed life cycle methods. If your activity class needs to do something special when it changes life cycle state, you can override the corresponding life cycle method in your Activity subclass. In fact, your activity classes will pretty much always need to override at least one of these life cycle methods. For instance, to initialize the UI, or load / save data etc.  A small note: The onRestart() life cycle method is called when the activity transitions from stopped to started. After onRestart() the life cycle method onStart() is called, and the activity is considered started again.  Here is an example Activity subclass called MyActivity which overrides all of the above life cycle methods:      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_my);     }      @Override     protected void onStart() {         super.onStart();     }      @Override     protected void onRestart() {         super.onRestart();     }      @Override     protected void onResume() {         super.onResume();     }      @Override     protected void onPause() {         super.onPause();     }      @Override     protected void onStop() {         super.onStop();     }      @Override     protected void onDestroy() {         super.onDestroy();     } } Notice how each of the life cycle methods call the corresponding method in the superclass. If your Activity subclass overrides one of the life cycle methods, it must call the corresponding method in the superclass inside the overridden method.  Creating an Activity When you create a new Android project in Android Studio the project will contain an Android Activity class already (unless you choose that is should not create an activity).  An activity is a subclass of the Android class android.app.Activity . Here is an example of how an Activity subclass could look:  package com.jenkov.myfirstandroidapp;  import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem;   public class MyFirstAndroidActivity extends Activity {  }     This Activity subclass does not do anything interesting. It just extends android.app.Activity .  When you create a blank activity in Android Studio the Activity subclass which Android Studio generates for you looks like this:  package com.jenkov.myfirstandroidapp;  import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem;   public class MyFirstAndroidActivity extends Activity {      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_my_first_android);     }       @Override     public boolean onCreateOptionsMenu(Menu menu) {         // Inflate the menu; this adds items to the action bar if it is present.         getMenuInflater().inflate(R.menu.my_first_android, menu);         return true;     }      @Override     public boolean onOptionsItemSelected(MenuItem item) {         // Handle action bar item clicks here. The action bar will         // automatically handle clicks on the Home/Up button, so long         // as you specify a parent activity in AndroidManifest.xml.         int id = item.getItemId();         if (id == R.id.action_settings) {             return true;         }         return super.onOptionsItemSelected(item);     } } Notice how this Activity subclass overrides the life cycle methods onCreate(), and the two other methods onCreateOptionsMenu() and onOptionsItemsSelected() . All of these methods will be covered in more detail later, so I won\'t say more about them here. What is important to know at this time is that the Activity subclass overrides methods inherited from the Activity class in order to do anything interesting.  Creating an Activity in Android Studio When you create a new project in Android Studio, the new project dialog will ask you if you want to create an activity as part of the project. If your app only needs a single activity (a single screen), you do not need to create more Activity subclasses.  However, if your app needs more than one activity, you can add an activity to your project via the File menu, by choosing the \"New…\" menu item. Here is where you find that menu item:  Creating a new Android Activity in Android Studio via File / New … In the menu that opens, click on the \"Activity\" menu item, and choose what kind of activity you want to create. Here is how that looks in Android Studio:  Creating a new Android Activity in Android Studio - choose Activity and then what kind of activity to create. Activity XML Layout Files An activity may have an associated XML layout file. The XML layout file specifies how the GUI components in the activity are to be rendered relative to each other. In the screenshot below I have marked the activity class and its associated layout XML file in Android Studio\'s project browser:  An activity and associated layout XML file shown in Android Studio\'s project browser. You are not forced to have a layout XML file for each activity. An activity can also create the layout programmatically (typically from inside the onCreate() method of the Activity subclass). However, in most cases it is easier to use a layout XML file. The layout XML file enables you to change the layout without having to change the code inside your Activity subclass.  Layout XML files will be covered in more detail in a later text in this Android development tutorial trail, so I will not talk more about them here.  onCreate() The Activity life cycle method onCreate() is the first method to get called by the Android operating system when an activity is created. Inside this method you should initialize the activity. Initialization of the activity includes initialization of the user interface components, and any other resources the activity needs to do its job.  Actually, some resources should be initialized in onStart() or onResume() and freed in onStop() or onPause(). It depends on how expensive it is to keep the resource open when it is not used, and whether the resource should remain open when not used.  Here is how the default onCreate() implementation looks for an activity generated by Android Studio:  @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_my_first_android); } First, super.onCreate() is called. Activity life cycle methods should always call their corresponding methods in the superclass.  Second, setContentView() is called. This method specifies what view is to be displayed inside the activity. An activity can only contain a single root view, but this root view may have multiple views nested inside it. Nesting views inside ViewGroups (which are also views) is how you compose more complex UIs.  The parameter passed to setContentView() is a constant pointing to the layout XML file for the activity. In this case it is the constant R.layout.activity_my_first_android . This constant was generated by Android Studio when I created the activity class. In fact, all constants inside the R class are generated by Android Studio or the Android SDK based on files located in your project (layout files, string files, images etc.).  The layout XML file the constant R.layout.activity_my_first_android points to is located in the directory app/src/main/res/layout , and is called activity_my_first_android.xml. This screenshot illustrates the location of this file in the Android Studio project:  The location of the file activity_my_firs_android.xml in the Android Studio project. Initializing The Activity UI After the call to setContentView() you could initialize the GUI components of the activity. Here is an example onCreate() implementation which initializes a single TextView component:  @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_my_first_android);      TextView textView = (TextView) findViewById(R.id.the_text_view);     textView.setText(\"I have changed the text!!\"); } The findViewById() method is inherited from the Activity class. The findViewById() method takes an id of the View component to find as parameter. The id is a constant which is also located inside the R class. In this case in R.id.the_text_view . This constant is generated based on the configuration of the TextView component inside the layout XML file for the activity. Notice the TextView element inside the RelativeLayout element. The TextView element has an attribute named android:id. The value of this attribute is @+id/the_text_view . This attribute value instructs the Android SDK to create an id constant named the_text_view. It is the + after the @ which tells the Anroid SDK to create the constant. If the + was not there, the attribute value would be interpreted as a reference to an id of a constant</string>
    <string name="fragments">An Android fragment is a GUI component which can "live" inside an Activity. An Android fragment is not by itself a subclass of View which most other GUI components are. Instead, a fragment has a view inside it. It is this view which is eventually displayed inside the activity in which the fragment lives.  Because an Android fragment is not a view, adding it to an activity looks somewhat different than adding a view (e.g. TextView). A fragment is added to a ViewGroup inside the activity. The fragment\'s view is displayed inside this ViewGroup. The following diagram shows what happens when you add a fragment to an activity:  Overview of how an Android fragment is added to an activity. First the activity obtains a reference to the fragment. Then it gets a reference to the ViewGroup the fragment\'s view will be rendered inside. Then the activity adds the fragment. The fragment then creates its view and returns it to the activity. The view is then inserted into the ViewGroup parent, and the fragment is alive.  Create a Fragment To create a fragment you must do two things:  Create a Fragment class. Create a Fragment layout XML file. Create a Fragment Class To create a Fragment class, create an ordinary Java class which extends android.app.Fragment. Here is an example:  import android.app.Fragment;   public class MyFragment extends Fragment {  } onCreateView() This Fragment subclass isn\'t doing anything yet. The MyFragment class needs to override the method onCreateView() inherited from Fragment in order to create the fragment\'s View which is to be displayed inside the activity the fragment is added to. Here is an example fragment onCreateView() implementation:  public class MyFragment extends Fragment {      @Override     public View onCreateView(LayoutInflater inflater, ViewGroup parentViewGroup,                              Bundle savedInstanceState) {          View rootView = inflater.inflate(R.layout.fragment_my, parentViewGroup, false);         return rootView;     } } The onCreateView() method gets a LayoutInflater, a ViewGroup and a Bundle as parameters.  The LayoutInflater is an component which can create View instance based on layout XML files. As you can see, the example actually does that by calling layout.inflate() .  The inflate() method takes three parameters: The id of a layout XML file (inside R.layout), a parent ViewGroup into which the fragment\'s View is to be inserted, and a third boolean telling whether the fragment\'s View as inflated from the layout XML file should be inserted into the parent ViewGroup. In this case we pass false because the View will be attached to the parent ViewGroup elsewhere, by some of the Android code we call (in other words, behind our backs). When you pass false as last parameter to inflate(), the parent ViewGroup is still used for layout calculations of the inflated View, so you cannot pass null as parent ViewGroup .  The ViewGroup parameter of onCreateView() is the parent ViewGroup into which the View of the fragment is to be inserted. This is a ViewGroup inside the activity that will \"host\" the fragment.  The Bundle parameter of onCreateView() is a Bundle into which the fragment can save information, just like an Activity can.  Add a Fragment to an Activity In order to have a fragment\'s View displayed inside an activity, you must add the fragment to the activity. You do so inside the activity. Here is an example which adds a fragment from inside onCreate() of the activity:  public class MyActivity extends Activity {      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.activity_my);          if (savedInstanceState == null) {             getFragmentManager()                     .beginTransaction()                     .add(R.id.fragmentParentViewGroup, new MyFragment())                     .commit();         }     }  } The fragment is added inside the if statement. Unlike other View components, the activity remembers what fragments were added to the activity. Therefore you should only add a fragment to an activity once in the activity\'s life span, or the fragment will appear multiple times. This is true even if the user changes orientation of the device between portrait and landscape, and even if the activity will be destroyed in this process. The Android OS will remember that a fragment was added to this activity when a new activity of this kind is created, and will re-attach the fragment to the activity.  If the savedInstanceState is null then this is the first time any state is created for this activity, so no fragment has been added to it yet. Remember, if an app is completely destroyed by Android, so is its savedInstanceState Bundle variable, and then you need to re-attach the fragment when the activity is started.  Fragments must be added (or replaced or removed) inside a FragmentTransaction. You obtain a FragmentTransaction via the FragmentManager. You get the FragmentManager via the getFragmentManager() method. From the FragmentManager you can obtain a FragmentTransaction by calling the beginTransaction() method. On the FragmentTransaction returned by beginTransaction() you can now add, replace or remove fragments to the activity.  It is the add() method on the FragmentTransaction which adds the fragment to the activity. The add() method takes two parameters. The first parameter is the id of the parent ViewGroup into which the fragment\'s View is to be inserted. The second parameter is an instance of the fragment to add.  When you are done adding, replacing or removing fragments you must commit the FragmentTransaction . You do so by calling the commit() method on the FragmentTransaction. Only when the FragmentTransaction is committed will all the changes you have made take effect.  Here is the activity\'s layout XML file. Notice the id of the root element is the same as referenced in the R.layout constant collection.This layout XML file has only a single FrameLayout element. This FrameLayout element is used as the parent ViewGroup for the fragment. Thus, in practice the fragment will take up the whole screen. You could have used a different ViewGroup as parent for the fragment. Here is an activity layout XML file example that shows how that could look:        Notice how the inner LinearLayout element has the id fragmentParentViewGroup . The fragment will use this LinearLayout as parent ViewGroup .  The Fragment Life Cycle An Android fragment has a life cycle which is similar to the activity life cycle. The fragment life cycle is illustrated here:  The Android fragment life cycle. First a fragment is added to an activity. This kicks off the fragment life cycle.  Second, the methods onAttach(), onCreate(), onCreateView(), onActivityCreated(), onStart() and onResume() are called. The onActivityCreated() is called when the hosting activity is fully created.  If the fragment is removed from its hosting activity, or the activity hosting the fragment is moved to the background of the app (another activity is moved to the foreground), then the onPause(), onStop() and onDestroyView() methods are called. If the fragment is returned to visibility, the fragment may transition from onDestroyView() to onCreateView() and become visible again.  Replace a Fragment You can replace a fragment added to an activity with another fragment. You do so via the replace() method on the FragmentTransaction object. Here is a FragmentTransaction replace() example:  getFragmentManager().beginTransaction()     .replace(R.id.fragmentParentViewGroup, new MySecondFragment())     .commit(); You can replace fragments while the activity is still alive. Once the activity is destroyed you can no longer replace fragments inside it.  You can replace fragments as many times as you want. You can replace fragments as a way to change part of the user interface, or the whole user interface if that is what you need / prefer.  Remove a Fragment You can remove a fragment from an activity using the FragmentTransaction. You do so via the remove() method. Here is a FragmentTransaction remove() example:  getFragmentManager().beginTransaction()         .remove(mySecondFragment)         .commit(); The remove() method takes a single parameter: A reference to the fragment to remove. The fragment will be removed from any parent ViewGroup the fragment was added to.  Adding Fragment Transactions to the Back Stack You can add a fragment transaction to the back stack. The back stack keeps track of actions in your app which can be backtracked when the user clicks Android\'s standard \"back\" button on the device. If you add a fragment transaction to the back stack then the transaction can be backtracked (reversed) with a click on the back button on the device.  Here is an example showing how to add a fragment transaction to the back stack:  MySecondFragment mySecondFragment = new MySecondFragment();  getFragmentManager().beginTransaction()         .replace(R.id.fragmentParentViewGroup, mySecondFragment)         .addToBackStack(null)         .commit(); This example replaces whatever fragment that was already added to the parent view group with the id R.id.fragmentParentViewGroup with the MySecondFragment instance. The example also adds the replacement transaction to the back stack. The addToBackStack() method takes an optional String parameter which can identify this state on the back stack. Most of the time you won\'t need this parameter so passing null is sufficient.  When this replacement transaction has been committed, it can be reversed by the user clicking the Android device\'s back button, in the same way the back button can take the user back to the previously visible activity.</string>
    <string name="views">View is the basic building block of UI(User Interface) in android. View refers to the android.view.View class, which is the super class for all the GUI components like TextView, ImageView, Button etc View class extends Object class and implements Drawable.Callback, KeyEvent.Callback and AccessibilityEventSource. View can be considered as a rectangle on the screen that shows some type of content. It can be an image, a piece of text, a button or anything that an android application can display. The rectangle here is actually invisible, but every view occupies a rectangle shape. The question that might be bothering you would be , what can be the size of this rectangle? The answer is either we can set it manually, by specifying the exact size(with proper units) or by using some predefined values. These predefined values are match_parent and wrap_content. match_parent means it will occupy the complete space available on the display of the device. Whereas, wrap_content means it will occupy only that much space as required for its content to display. match_parent and wrap_content in Android View A View is also known as Widget in Android. Any visual(that we can see on screen) and interactive(with which user can interact with) is called a Widget.</string>
    <string name="dataalgorithms">A data structure is a method of organizing data in a virtual system. Think of sequences of numbers, or tables of data: these are both well-defined data structures. An algorithm is a sequence of steps executed by a computer that takes an input and transforms it into a target output.  Together, data structures and algorithms combine and allow programmers to build whatever computer programs they’d like. Deep study into data structures and algorithms ensures well-optimized and efficient code.  How Do Data Structures and Algorithms Work Together? There are many algorithms for different purposes. They interact with different data structures in the same computational complexity scale. Think of algorithms as dynamic underlying pieces that interact with static data structures.  The way data is expressed in code is flexible. Once you understand how algorithms are built, you can generalize across different programming languages. In a sense, it’s a bit like knowing how a related family of languages work syntactically. Once you glimpse the fundamental rules behind programming languages and their organizing principles, you can more easily switch between the different languages and learn each faster.  Common Data Structures and Algorithms Common data structures you’ll see across different programming languages include:  Linked lists Stacks Queues Sets Maps Hash tables Search trees Each of these has its own computational complexity for associated functions like adding items and finding aggregate measures such as the mean for the underlying data structure.  Some common categories of algorithms are:  Search Sorting Graph/tree traversing Dynamic programming Hashing and regex (string pattern matching)</string>
    <string name="uidesigns">User interface (UI) design is the process designers use to build interfaces in software or computerized devices, focusing on looks or style. Designers aim to create interfaces which users find easy to use and pleasurable. UI design refers to graphical user interfaces and other forms—e.g., voice-controlled interfaces.</string>
    <string name="gradle">In Android Studio, Gradle is used for building our android application projects, hence playing the role of a build system. Before Android Studio, in Eclipse we used to compile and build the applications using command line tool which was soon taken over by GUI based steps to build and run Android Applications in eclipse using ANT. Every android application development tool has to compile resources, java source code, external libraries and combine them into a final APK.
Gradle is a build system, which is responsible for code compilation, testing, deployment and conversion of the code into .dex files and hence running the app on the device. As Android Studio comes with Gradle system pre-installed, there is no need to install additional runtime softwares to build our project. Whenever you click on Run button in android studio, a gradle task automatically triggers and starts building the project and after gradle completes its task, app starts running in AVD or in the connected device. A build system like Gradle is not a compiler, linker etc, but it controls and supervises the operation of compilation, linking of files, running test cases, and eventually bundling the code into an apk file for your Android Application. There are two build.gradle files for every android studio project of which, one is for application and other is for project level(module level) build files. The build process works as shown in the below diagram Conversion of Android Code to APK with Gradle In the build process, the compiler takes the source code, resources, external libraries JAR files and AndroidManifest.xml(which contains the meta-data about the application) and convert them into .dex(Dalvik Executable files) files, which includes bytecode. That bytecode is supported by all android devices to run your app. Then APK Manager combines the .dex files and all other resources into single apk file. APK Packager signs debug or release apk using respective debug or release keystore. Debug apk is generally used for testing purpose or we can say that it is used at development stage only. When your app is complete with desired features and you are ready to publish your application for external use then you require a Release apk signed using a release keystore. Now lets shed some light on the gradle files. setting.gradle The setting.gradle(Gradle setting) file is used to specify all the modules used in your app. build.gradle (project level) The Top level (module) build.gradle file is project level build file, which defines build configurations at project level. This file applies configurations to all the modules in android application project. build.gradle (application level) The Application level build.gradle file is located in each module of the android project. This file includes your package name as applicationID, version name(apk version), version code, minimum and target sdk for a specific application module. When you are including external libraries(not the jar files) then you need to mention it in the app level gradle file to include them in your project as dependencies of the application.
Note: If a certain application is developed in variations for individual modules like, Smart Phone, Tablet or TV then separate gradle files must to be created for all. You can even start your gradle system through command line tool. Following commands are used for it: ./gradlew build - (build project) ./gradlew clean build - (build project complete scratch) ./gradlew clean build - (run the test) ./gradlew wrapper - (to see all the available tasks) Android Build Process ART - Android Runtime The Dalvik Virtual Machine is dead. Yes, Google stopped using it in 2014, although you will find most of the Android tutorials online, still not updated, but please be informed that Dalvik Virtual Machine is not used in Android anymore. The new runtime is known as ART or Android Runtime which is very well compatible with its predecessor Dalvik, but do comes in with a lot of new features like: Ahead-of-Time compilation Improved Garbage collection Improved Debugging and diagnostics.</string>
    <string name="keeplearning">Android developers are always in high demand today due to the advance computational knowledge it reguires to be a skilled android dev. If you decide to stick with android development, chances are you are going to succeed. In time and with continued practice you can make it to the top one percent of programmers in the world. and that comes with a huge pay raise. High work load with equal work pay. You understand. I will not always be easy and their are plenty of times you may want to give up but chance are if you keep at it youd become incredibly valuable and the feeling would be absolutely awesome becasue that is something no one and i mean absolutely no one can take it away from you…!!!</string>


</resources>